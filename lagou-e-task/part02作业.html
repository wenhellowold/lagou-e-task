<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    // 1. 10
    // 因为程序在执行的时候会进行变量提升，var声明的变量会被提升，在函数执行的时候var会被循环重新赋值，故输出为10

    // 2。报错
    // 因为let会声明一个块级作用域，在let声明变量之前，这个变量都是不可用的，这个区域被称为暂时性死区

    // 3
    var arr = [12,34,32,89,4]
    let min = Math.min(...arr)
    console.log(min)

    // 4
    //（1）块级作用域： 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。
    // 块级作用域解决了ES5中的两个问题：
    // 内层变量可能覆盖外层变量
    // 用来计数的循环变量泄露为全局变量

    // （2）变量提升： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。

    // （3）给全局添加属性： 浏览器的全局对象是window，Node的全局对象是global。
    // var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。
    // （4）重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。

    // （6）初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。
    // （7）指针指向： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。

    // 5
    var a = 10
    var obj = {
        a:20,
        fn(){
            setTimeout(()=>{
                console.log(this.a)
            },0)
        }
    }
    obj.fn()

    // 20, 因为是obj调用的函数，所以this指向obj，

    // 6.
    // symbols 是一种无法被重建的基本类型。这时 symbols 有点类似与对象创建的实例互相不相等的情况，但同时 symbols 又是一种无法被改变的基本类型数据。
    // symbols 有另一个很重要的用途，就是用作对象的 key。阻止对象属性名冲突

    //7
    // 浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 。
    // 深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象。
    // 区别：浅拷贝基本类型之前互不影响，引用类型其中一个对象改变了地址，就会影响另一个对象；深拷贝
    // 改变新对象不会影响原对象，他们之前互不影响

    // 8
    // ts是js的超集，即你可以在ts中使用原生js语法。
    // ts需要静态编译，它提供了强类型与更多面向对象的内容。
    // ts最终仍要编译为弱类型的js文件，基于对象的原生的js，再运行。故ts相较java/C#这样天生面向对象语言是有区别和局限的

    
</script>
</html>